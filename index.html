<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Axelrod</title>
    <style>
        html, body {
            padding: 0px;
            margin: 0px;
            width: 100%;
            height: 100%;
            line-height: 1.5em;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 0.95em;
        }

        header {
            width: 100%;
            padding: 10px;
        }

        #description {
            width: 100%;
            padding: 10px;
        }

        #content {
            width: 100%;
            height: 100%;
        }

        #vis {
            height: 90%;
            width: 100%;
        }

        #choice {
            width: 100%;
            padding: 10px 20px;
        }

        .axis path,
        .axis line {
          fill: none;
          stroke: #000;
          shape-rendering: crispEdges;
        }

        @media(min-width: 600px) {
            html, body {
                font-size: 1.0em;
            }

            header {
                float: left;
                width: 29%;
            }

            #description {
                float: left;
                clear: left;
                width: 29%;
            }

            #content {
                float: right;
                width: 69%;
                height: 100%;
            }
        }

    </style>
</head>
<body>
    <header>
        <h1>Axelrod</h1>
        <p>
This repository reproduces Axelrod's iterated prisoner's dilemma. Contributions are welcome via pull request.</p>

<h2>History of Axelrod's tournament</h2>
<p>In the 1980s, professor of Political Science Robert Axelrod ran a tournament inviting strategies from collaborators all over the world for the Iterated Prisoner's Dilemma. You can read about this more here.</p>
    </header>
    <div id="content">
        <form id="choice">
            <label for="result_select">
            Select Results: 
            <select id="result_select">
                <option selected value="all_results">All Results</option>
                <option value="cheating_results">Cheating Results</option>
                <option value="results">No Cheaters</option>
            </select>
        </label>
        </form>
        <div id="vis">
        </div>
    </div>
    <div id="description">
        <h2>Contributing</h2>
        <p>This repository contains Python (2.7) code that reproduces the tournament. You can see the results from the latest run of the tournament here. All contributions are welcome: with a particular emphasis on contributing further strategies.</p>
    </div>
    <script src="//cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
    <script src="colorbrewer.js"></script>
    <script>

        // find the 
        function iqr(d) {
            var q1 = d3.quantile(d, 0.25);
            var q3 = d3.quantile(d, 0.75);
            var iqr = (q3 - q1) * 1.5;
            var i = -1;
            var j = d.length;
            while (d[++i] < (q1 - iqr));
            while (d[--j] > (q3 + iqr));
            return [i, j];
        }

        var svg;

        var width = document.getElementById("vis").clientWidth;
        var height = document.getElementById("vis").clientHeight;

        var padding_bottom = 170;
        var padding_left = 90;
        var padding_right = 40;
        var padding_top = 40;

        var transition_duration = 1000;

        var y_scale = d3.scale.linear()
            .range([height-padding_bottom, padding_top]);

        var x_scale = d3.scale.ordinal()
            .rangeRoundBands([padding_left, width-padding_right], 0.5, 0.4);

        var colour_scale = d3.scale.quantile()
            .range(colorbrewer.Blues[9]);

        var x_axis = d3.svg.axis()
            .scale(x_scale)
            .orient("bottom");

        var y_axis = d3.svg.axis()
            .scale(y_scale)
            .orient("left")
            .tickFormat(d3.format(".3s"));

        var results;
        var keys;

        var init_plot = function() {
            svg = d3.select('#vis')
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            svg.append("g")
              .attr("class", "x axis")
              .attr("transform", "translate(0," + (height-padding_bottom) + ")");

            svg.selectAll('.x.axis text')
                .style("text-anchor", "end")
                .attr("transform", "translate(-15,10)rotate(-90)");

            svg.append("g")
              .attr("class", "y axis")
              .attr("transform", "translate(" + (padding_left) + ", " + "0)")
            .append("text")
              .attr("transform", "translate(-60," + height/4 + ")rotate(-90)")
              .style("text-anchor", "end")
              .text("Mean score per game over 200 rounds repeated 50 times");
        }

        var draw_outlier = function(element, x, y) {
            var circle = element.append('circle')
                .attr('cx', x)
                .attr('cy', y)
                .attr('r', 2)
                .attr('stroke', '#aaa')
                .attr('stroke-width', 0.5)
                .attr('fill', 'none')
                .attr('class', 'outlier')
                .style('opacity', 0);            
        }

        var load_results = function(results) {
            
            d3.csv(results + '.csv', function(error, data) {

                // extract the list of players
                keys = data.map(function(d) {
                    return d.player;
                });

                // coerce data into a proper format - array of numerical scores
                data.forEach(function(d){
                    var temp = d.scores.replace('[', '')
                    temp = temp.replace(']', '')
                    scores = temp.split(',')
                    d.scores = scores.map(function(s) { return +s/(200 * (keys.length-1)); });
                    d.scores = d.scores.sort();
                });

                results = data;

                var max = d3.max(results, function(d){ return d3.max(d.scores); });
                var min = d3.min(results, function(d){ return d3.min(d.scores); });
                var medians = [];
                results.forEach(function(d){ 
                    medians.push(d3.median(d.scores)); 
                });

                colour_scale.domain(medians);

                y_scale
                    .domain([min, max]);

                x_scale
                    .domain(keys);

                draw_plot(results);
            });
        }

        var draw_plot = function(results) {
        
            svg.selectAll('.box')
                .style("opacity", 0)
                .remove();

            var boxes = svg.selectAll('.box')
                .data(results);

            var box = boxes
                .enter()
                .append('g')
                .attr('class', function(d){ return "box " + d.player; });

            box
                .append('rect')
                .attr('class', 'quartiles')
                .attr('x', function(d) {
                    return x_scale(d.player)
                })
                .attr('width', x_scale.rangeBand())
                .attr('y', function(d){
                    var upper_quartile = d3.quantile(d.scores, 0.75);
                    return y_scale(upper_quartile);
                })
                .attr('height', function(d) {
                    var lower_quartile = d3.quantile(d.scores, 0.25);
                    var upper_quartile = d3.quantile(d.scores, 0.75);
                    return y_scale(lower_quartile)-y_scale(upper_quartile);
                })
                .attr("fill", function(d) {
                    return colour_scale(d3.median(d.scores));
                })
                .attr("stroke", "blue")
                .style('opacity', 0);
            
            box
                .append('path')
                .attr('class', 'median')
                .attr('d', function(d) {
                    var median = d3.median(d.scores);
                    var band_width = x_scale.rangeBand();
                    var x_start = x_scale(d.player);
                    var y = y_scale(median);
                    var path = "M " + x_start + " " + y + " L " + " " + (x_start+band_width) + " " + y;
                    return path;
                })
                .attr('stroke', 'red')
                .attr('stroke-width', '2')
                .style('opacity', 0);

            box
                .append('path')
                .attr('class', 'upper-whisker')
                .attr('d', function(d) {
                    var lower_quartile = d3.quantile(d.scores, 0.25);
                    var upper_quartile = d3.quantile(d.scores, 0.75);
                    var i = iqr(d.scores)
                    var reach = d.scores[i[1]];
                    var band_width = x_scale.rangeBand();
                    var x_start = x_scale(d.player);

                    if(i[1] < d.scores.length-1) {
                        for(var j = i[1]; j < d.scores.length; j++) {
                            draw_outlier(box, (x_start + (band_width/2)), y_scale(d.scores[j]));
                        }
                    }

                    var path = "M " + (x_start + (band_width/2)) + " " + y_scale(upper_quartile) + " L " + (x_start + (band_width/2)) + " " + y_scale(reach) + " " + (x_start + band_width) + " " + y_scale(reach) + " " + x_start + " " +  y_scale(reach);
                    return path;
                })
                .attr('stroke', 'black')
                .attr('fill', 'none')
                .style('opacity', 0);

            box
                .append('path')
                .attr('class', 'lower-whisker')
                .attr('stroke', 'black')
                .attr('fill', 'none')
                .attr('d', function(d) {
                    var lower_quartile = d3.quantile(d.scores, 0.25);
                    var upper_quartile = d3.quantile(d.scores, 0.75);
                    var i = iqr(d.scores)
                    var reach = d.scores[i[0]];
                    var band_width = x_scale.rangeBand();
                    var x_start = x_scale(d.player);

                    if(i[0] > 0) {
                        for(var j = 0; j < i[0]; j++) {
                            draw_outlier(box, (x_start + (band_width/2)), y_scale(d.scores[j]));
                        }
                    }

                    var path = "M " + (x_start + (band_width/2)) + " " + y_scale(lower_quartile) + " L " + (x_start + (band_width/2)) + " " + y_scale(reach) + " " + (x_start + band_width) + " " + y_scale(reach) + " " + x_start + " " +  y_scale(reach);
                    return path;
                })
                .style('opacity', 0);
            
            boxes.selectAll('.median')
                .transition()
                .duration(transition_duration)
                .style('opacity', 1);

            boxes.selectAll('.quartiles')
                .transition()
                .duration(transition_duration)
                .style('opacity', 1);

            boxes.selectAll('.upper-whisker')
                .transition()
                .duration(transition_duration)
                .style('opacity', 1);

            boxes.selectAll('.lower-whisker')
                .transition()
                .duration(transition_duration)                
                .style('opacity', 1);

            boxes.selectAll('.outlier')
                .transition()
                .duration(transition_duration)                
                .style('opacity', 1);

            boxes
                .exit()
                .transition()
                .duration(transition_duration)
                .style('opacity', 0)
                .remove();
              

            svg.select('.x.axis')
                .transition()
                .duration(transition_duration)
                .call(x_axis);

            svg.select('.x.axis')
                .selectAll('text')
                .attr('transform', 'translate(-15, 15)rotate(-90)')
                .style('text-anchor', 'end');

            svg.select('.y.axis')
                .transition()
                .duration(transition_duration)
                .call(y_axis);
        }

        d3.select('#result_select')
            .on('change', function() {
                var selected = this.options[this.selectedIndex].value;
                load_results(selected);
            })
        init_plot();
        load_results('all_results');

    </script>
</body>
</html>