#!/usr/bin/env python
"""Run axelrod

Usage:
    run_axelrod [-h] [-t TURNS] [-e PROBEND] [-r REPETITIONS] [-n NOISE] [-o
    OUTPUTDIRECTORY] [-i IMAGE-FORMAT] [-c CACHE] [-p PROCESSES] [--rc] [--xb] [--xo] [--xc] [--xa]

Options:
    -h --help                    show a help message
    -t TURNS                     turns per match [default: 200]
    -e PROBEND                   probability of a match ending (if provided, overrides turns) [default: ""]
    -r REPETITIONS               repetitions of each tournament [default: 100]
    -n NOISE                     noise level [default: 0]
    -o OUTPUT-DIRECTORY          output directory [default: None]
    -i IMAGE-FORMAT              image format for output, e.g. svg, jpg, png [default: svg]
    -c CACHE                     path to cache file [default: None]
    -p PROCESSES                 number of parallel processes to spwan. 0 uses cpu count [default: None]
    --rc                         rebuild cache and save to file

    --xb                         exclude basic strategies
    --xo                         exclude ordinary strategies
    --xc                         exclude cheating strategies
    --xa                         exclude combined strategies
"""
from docopt import docopt
import axelrod as axl
import os

def all_plots(label, results, filename_suffix, file_format, output_directory):
    """Obtain all plots"""
    plot = axl.Plot(results)

    f = plot.boxplot(title="Payoff " + label)
    filename = os.path.join(output_directory,
                            "{}_boxplot.{}".format(filename_suffix, file_format))
    f.savefig(filename)

    f = plot.payoff(title="Payoff " + label)
    filename = os.path.join(output_directory,
                            "{}_payoff.{}".format(filename_suffix, file_format))
    f.savefig(filename)

    f = plot.winplot(title="Wins " + label)
    filename = os.path.join(output_directory,
                            "{}_winplot.{}".format(filename_suffix, file_format))
    f.savefig(filename)

    f = plot.sdvplot(title="Payoff differences " + label)
    filename = os.path.join(output_directory,
                            "{}_sdvplot.{}".format(filename_suffix, file_format))
    f.savefig(filename)

    f = plot.pdplot(title="Payoff differences " + label)
    filename = os.path.join(output_directory,
                            "{}_pdplot.{}".format(filename_suffix, file_format))
    f.savefig(filename)

    eco = axl.Ecosystem(results)
    eco.reproduce(1000)
    f = plot.stackplot(eco, title="Eco " + label)
    filename = os.path.join(output_directory,
                            "{}_repdroduce.{}".format(filename_suffix, file_format))
    f.savefig(filename)


def run_tournament(players, turns=200, repetitions=100, prob_end=None,
                   noise=None, processes=0, cache=None):
    """Run a given tournament, returns results set and a label for plots"""
    print("Running tournament with {} strategies".format(len(players)))
    if cache is None:
        cache = axl.DeterministicCache()

    if prob_end is not None:
        tournament = axl.ProbEndTournament(players, repetitions=repetitions,
                                           prob_end=prob_end, noise=noise,
                                           processes=processes,
                                           deterministic_cache=cache)
        label = "Prob end: {}, repetitions: {}, noise: {}, strategies: {}. ".format(prob_end, tournament.repetitions, noise, len(tournament.players))

    else:
        tournament = axl.ProbEndTournament(players, repetitions=repetitions,
                                           turns=turns, noise=noise,
                                           processes=processes,
                                           deterministic_cache=cache)
        label = "Turns: {}, repetitions: {}, noise: {}, strategies: {}. ".format(turns, tournament.repetitions, noise, len(tournament.nplayers))

    return tournament.play(), label


if __name__ == '__main__':
    arguments = docopt(__doc__, version='Run Axelrod 0.1')

    # Parse arguments
    turns = int(arguments['-t'])
    repetitions = int(arguments['-r'])
    prob_end = float(arguments['-e'])
    noise = float(arguments['-n'])
    processes = eval(arguments['-p'])

    output_directory = arguments['-o']
    if output_directory == "None":
        output_directory = None
    cache_file = arguments['-c']
    if cache_file == "None":
        cache_file = None

    image_format = arguments['-i']
    rebuild_cache = arguments['--rc']
    exclude_basic = arguments['--xb']
    exclude_ordinary = arguments['--xo']
    exclude_cheaters = arguments['--xc']
    exclude_combined = arguments['--xa']

    # Build play lists
    player_lists = []
    file_suffixes = []
    if not exclude_basic:  # Basic strategies not excluded
        player_lists.append([s() for s in axl.basic_strategies])
        file_suffixes.append("basic_strategies_")
    if not exclude_ordinary:  # Ordinary strategies not excluded
        player_lists.append([s() for s in axl.ordinary_strategies])
        file_suffixes.append("ordinary_strategies_")
    if not exclude_cheaters:  # Cheating strategies not excluded
        player_lists.append([s() for s in axl.cheating_strategies])
        file_suffixes.append("cheating_strategies_")
    if not exclude_combined:  # All strategies not excluded
        player_lists.append([s() for s in axl.strategies])
        file_suffixes.append("strategies_")

    # Build the cache
    if cache_file and not rebuild_cache:
        cache = axl.DeterministicCache(cache_file)
    else:
        cache = axl.DeterministicCache()

    # run the tournaments
    for players, suffix in zip(player_lists, file_suffixes):
        results, label = run_tournament(players, turns=turns,
                                        repetitions=repetitions, prob_end=prob_end,
                                        noise=noise, processes=processes,
                                        cache=cache)
        all_plots(label, results, suffix, image_format, output_directory)


    # save the cache to file
    if rebuild_cache:
       cache.save(cache_file)
